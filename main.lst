   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setup_timer
  12               	setup_timer:
  13               	.LFB7:
  14               		.file 1 "main.c"
   1:main.c        **** /* ledblink.c, an LED blinking program */
   2:main.c        **** #include "serial.h"
   3:main.c        **** #include "imu.h"
   4:main.c        **** #include "nunchuck.h"
   5:main.c        **** #include "motor.h"
   6:main.c        **** 
   7:main.c        **** #include <avr/io.h>
   8:main.c        **** #include <util/delay.h>
   9:main.c        **** #include <avr/interrupt.h>
  10:main.c        **** #include <math.h>
  11:main.c        **** 
  12:main.c        **** void setup_timer() {
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  13:main.c        ****     // 1/64 prescaler
  14:main.c        ****     TCCR0B = (1<<CS01) | (1<<CS00);
  21               		.loc 1 14 0
  22 0000 83E0      		ldi r24,lo8(3)
  23 0002 85BD      		out 0x25,r24
  15:main.c        ****     TCCR0A |= (1 << WGM01);
  24               		.loc 1 15 0
  25 0004 84B5      		in r24,0x24
  26 0006 8260      		ori r24,lo8(2)
  27 0008 84BD      		out 0x24,r24
  16:main.c        ****     OCR0A = 249; // 1kHz
  28               		.loc 1 16 0
  29 000a 89EF      		ldi r24,lo8(-7)
  30 000c 87BD      		out 0x27,r24
  17:main.c        ****     TIMSK0 |= (1<<OCIE0A);
  31               		.loc 1 17 0
  32 000e EEE6      		ldi r30,lo8(110)
  33 0010 F0E0      		ldi r31,0
  34 0012 8081      		ld r24,Z
  35 0014 8260      		ori r24,lo8(2)
  36 0016 8083      		st Z,r24
  18:main.c        ****     sei();
  37               		.loc 1 18 0
  38               	/* #APP */
  39               	 ;  18 "main.c" 1
  40 0018 7894      		sei
  41               	 ;  0 "" 2
  42               	/* #NOAPP */
  43 001a 0895      		ret
  44               		.cfi_endproc
  45               	.LFE7:
  47               		.section	.text.startup,"ax",@progbits
  48               	.global	main
  50               	main:
  51               	.LFB8:
  19:main.c        **** }
  20:main.c        **** 
  21:main.c        **** int main() {
  52               		.loc 1 21 0
  53               		.cfi_startproc
  54               	/* prologue: function */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
  58               	.LVL0:
  59               	.LBB6:
  60               	.LBB7:
  61               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  62               		.loc 2 164 0
  63 0000 2FEF      		ldi r18,lo8(319999)
  64 0002 81EE      		ldi r24,hi8(319999)
  65 0004 94E0      		ldi r25,hlo8(319999)
  66 0006 2150      		1: subi r18,1
  67 0008 8040      		sbci r24,0
  68 000a 9040      		sbci r25,0
  69 000c 01F4      		brne 1b
  70 000e 00C0      		rjmp .
  71 0010 0000      		nop
  72               	.LBE7:
  73               	.LBE6:
  22:main.c        ****     _delay_ms(100);
  23:main.c        ****     uart_init(UART_RX_EN | UART_TX_EN);
  74               		.loc 1 23 0
  75 0012 88E1      		ldi r24,lo8(24)
  76 0014 0E94 0000 		call uart_init
  77               	.LVL1:
  24:main.c        ****     stdout = stdin = &uartfile;
  78               		.loc 1 24 0
  79 0018 80E0      		ldi r24,lo8(uartfile)
  80 001a 90E0      		ldi r25,hi8(uartfile)
  81 001c 9093 0000 		sts __iob+1,r25
  82 0020 8093 0000 		sts __iob,r24
  83 0024 9093 0000 		sts __iob+2+1,r25
  84 0028 8093 0000 		sts __iob+2,r24
  25:main.c        ****     i2c_init();
  85               		.loc 1 25 0
  86 002c 0E94 0000 		call i2c_init
  87               	.LVL2:
  26:main.c        ****     imu_init();
  88               		.loc 1 26 0
  89 0030 0E94 0000 		call imu_init
  90               	.LVL3:
  91               	.LBB8:
  92               	.LBB9:
  93               		.loc 2 164 0
  94 0034 2FEF      		ldi r18,lo8(1599999)
  95 0036 89E6      		ldi r24,hi8(1599999)
  96 0038 98E1      		ldi r25,hlo8(1599999)
  97 003a 2150      		1: subi r18,1
  98 003c 8040      		sbci r24,0
  99 003e 9040      		sbci r25,0
 100 0040 01F4      		brne 1b
 101 0042 00C0      		rjmp .
 102 0044 0000      		nop
 103               	.LBE9:
 104               	.LBE8:
  27:main.c        ****     //nck_init();
  28:main.c        ****     // Allow time for gyro to settle
  29:main.c        ****     _delay_ms(500);
  30:main.c        ****     DDRC |= (1<<PC0);
 105               		.loc 1 30 0
 106 0046 389A      		sbi 0x7,0
  31:main.c        ****     PORTC ^= (1<<PC0);
 107               		.loc 1 31 0
 108 0048 88B1      		in r24,0x8
 109 004a 91E0      		ldi r25,lo8(1)
 110 004c 8927      		eor r24,r25
 111 004e 88B9      		out 0x8,r24
  32:main.c        ****     setup_timer();
 112               		.loc 1 32 0
 113 0050 0E94 0000 		call setup_timer
 114               	.LVL4:
 115               	.L3:
 116 0054 00C0      		rjmp .L3
 117               		.cfi_endproc
 118               	.LFE8:
 120               	.global	__floatsisf
 121               	.global	__mulsf3
 122               	.global	__divsf3
 123               	.global	__addsf3
 124               	.global	__subsf3
 125               	.global	__ltsf2
 126               	.global	__gesf2
 127               	.global	__gtsf2
 128               	.global	__lesf2
 129               	.global	__fixsfsi
 130               		.text
 131               	.global	__vector_14
 133               	__vector_14:
 134               	.LFB9:
  33:main.c        ****     while(1) {
  34:main.c        ****         //printf("Hello world\n");
  35:main.c        **** 
  36:main.c        ****         //nck_read_data(&nck_data);
  37:main.c        ****         //imu_read_data(&imu_data);
  38:main.c        ****         //printf("G(x: % 6d, y: % 6d, z: % 6d) ", imu_data.gyro.x, imu_data.gyro.y, imu_data.gyro.z
  39:main.c        ****         //printf("A(x: % 6d, y: % 6d, z: % 6d) ", imu_data.accel.x, imu_data.accel.y, imu_data.acce
  40:main.c        ****         //printf("M(x: % 6d, y: % 6d, z: % 6d) ", imu_data.mag.x, imu_data.mag.y, imu_data.mag.z);
  41:main.c        ****         //printf("NS(x: % 6d, y: % 6d) ", nck_data.sx, nck_data.sy);
  42:main.c        ****         //printf("NA(x: % 6d, y: % 6d, z: % 6d) ", nck_data.ax, nck_data.ay, nck_data.az);
  43:main.c        ****         //printf("\n");
  44:main.c        ****     }
  45:main.c        ****     return 0;
  46:main.c        **** }
  47:main.c        **** 
  48:main.c        **** #define DRIVE_STATE_START 0
  49:main.c        **** #define DRIVE_STATE_NEG_START 1
  50:main.c        **** #define DRIVE_STATE_POS_START 2
  51:main.c        **** #define DRIVE_STATE_DRIVING 3
  52:main.c        **** uint8_t drive_state = DRIVE_STATE_START;
  53:main.c        **** 
  54:main.c        **** #define START_AVG 100;
  55:main.c        **** #define RAD_TO_DEG 57.295779513f
  56:main.c        **** uint16_t startup = START_AVG;
  57:main.c        **** //Exponential average gyro zero rate over 20 seconds
  58:main.c        **** const double alpha = 0.00001;
  59:main.c        **** //Filter in acceleration angle over 4 seconds
  60:main.c        **** const double beta = 0.02;
  61:main.c        **** double gyro_zero = 0.0f;
  62:main.c        **** double gyro_rate;
  63:main.c        **** double rotation_speed;
  64:main.c        **** double accel_angle;
  65:main.c        **** 
  66:main.c        **** double angle = 0.0f;
  67:main.c        **** struct IMU imu_data;
  68:main.c        **** struct NCK nck_data;
  69:main.c        **** 
  70:main.c        **** double kp = 2.2;
  71:main.c        **** double kd = 75.0;
  72:main.c        **** 
  73:main.c        **** double target_angle = 0.0f;
  74:main.c        **** double thrust;
  75:main.c        **** 
  76:main.c        **** uint16_t loop_count = 0;
  77:main.c        **** uint16_t print_count = 0;
  78:main.c        **** 
  79:main.c        **** ISR(TIMER0_COMPA_vect) {
 135               		.loc 1 79 0
 136               		.cfi_startproc
 137 001c 1F92      		push r1
 138               	.LCFI0:
 139               		.cfi_def_cfa_offset 3
 140               		.cfi_offset 1, -2
 141 001e 0F92      		push r0
 142               	.LCFI1:
 143               		.cfi_def_cfa_offset 4
 144               		.cfi_offset 0, -3
 145 0020 0FB6      		in r0,__SREG__
 146 0022 0F92      		push r0
 147 0024 1124      		clr __zero_reg__
 148 0026 8F92      		push r8
 149               	.LCFI2:
 150               		.cfi_def_cfa_offset 5
 151               		.cfi_offset 8, -4
 152 0028 9F92      		push r9
 153               	.LCFI3:
 154               		.cfi_def_cfa_offset 6
 155               		.cfi_offset 9, -5
 156 002a AF92      		push r10
 157               	.LCFI4:
 158               		.cfi_def_cfa_offset 7
 159               		.cfi_offset 10, -6
 160 002c BF92      		push r11
 161               	.LCFI5:
 162               		.cfi_def_cfa_offset 8
 163               		.cfi_offset 11, -7
 164 002e CF92      		push r12
 165               	.LCFI6:
 166               		.cfi_def_cfa_offset 9
 167               		.cfi_offset 12, -8
 168 0030 DF92      		push r13
 169               	.LCFI7:
 170               		.cfi_def_cfa_offset 10
 171               		.cfi_offset 13, -9
 172 0032 EF92      		push r14
 173               	.LCFI8:
 174               		.cfi_def_cfa_offset 11
 175               		.cfi_offset 14, -10
 176 0034 FF92      		push r15
 177               	.LCFI9:
 178               		.cfi_def_cfa_offset 12
 179               		.cfi_offset 15, -11
 180 0036 0F93      		push r16
 181               	.LCFI10:
 182               		.cfi_def_cfa_offset 13
 183               		.cfi_offset 16, -12
 184 0038 1F93      		push r17
 185               	.LCFI11:
 186               		.cfi_def_cfa_offset 14
 187               		.cfi_offset 17, -13
 188 003a 2F93      		push r18
 189               	.LCFI12:
 190               		.cfi_def_cfa_offset 15
 191               		.cfi_offset 18, -14
 192 003c 3F93      		push r19
 193               	.LCFI13:
 194               		.cfi_def_cfa_offset 16
 195               		.cfi_offset 19, -15
 196 003e 4F93      		push r20
 197               	.LCFI14:
 198               		.cfi_def_cfa_offset 17
 199               		.cfi_offset 20, -16
 200 0040 5F93      		push r21
 201               	.LCFI15:
 202               		.cfi_def_cfa_offset 18
 203               		.cfi_offset 21, -17
 204 0042 6F93      		push r22
 205               	.LCFI16:
 206               		.cfi_def_cfa_offset 19
 207               		.cfi_offset 22, -18
 208 0044 7F93      		push r23
 209               	.LCFI17:
 210               		.cfi_def_cfa_offset 20
 211               		.cfi_offset 23, -19
 212 0046 8F93      		push r24
 213               	.LCFI18:
 214               		.cfi_def_cfa_offset 21
 215               		.cfi_offset 24, -20
 216 0048 9F93      		push r25
 217               	.LCFI19:
 218               		.cfi_def_cfa_offset 22
 219               		.cfi_offset 25, -21
 220 004a AF93      		push r26
 221               	.LCFI20:
 222               		.cfi_def_cfa_offset 23
 223               		.cfi_offset 26, -22
 224 004c BF93      		push r27
 225               	.LCFI21:
 226               		.cfi_def_cfa_offset 24
 227               		.cfi_offset 27, -23
 228 004e EF93      		push r30
 229               	.LCFI22:
 230               		.cfi_def_cfa_offset 25
 231               		.cfi_offset 30, -24
 232 0050 FF93      		push r31
 233               	.LCFI23:
 234               		.cfi_def_cfa_offset 26
 235               		.cfi_offset 31, -25
 236 0052 CF93      		push r28
 237               	.LCFI24:
 238               		.cfi_def_cfa_offset 27
 239               		.cfi_offset 28, -26
 240 0054 DF93      		push r29
 241               	.LCFI25:
 242               		.cfi_def_cfa_offset 28
 243               		.cfi_offset 29, -27
 244 0056 00D0      		rcall .
 245 0058 00D0      		rcall .
 246               	.LCFI26:
 247               		.cfi_def_cfa_offset 32
 248 005a CDB7      		in r28,__SP_L__
 249 005c DEB7      		in r29,__SP_H__
 250               	.LCFI27:
 251               		.cfi_def_cfa_register 28
 252               	/* prologue: Signal */
 253               	/* frame size = 4 */
 254               	/* stack size = 31 */
 255               	.L__stack_usage = 31
  80:main.c        ****     switch (loop_count) {
 256               		.loc 1 80 0
 257 005e 8091 0000 		lds r24,loop_count
 258 0062 9091 0000 		lds r25,loop_count+1
 259 0066 8330      		cpi r24,3
 260 0068 9105      		cpc r25,__zero_reg__
 261 006a 01F4      		brne .+2
 262 006c 00C0      		rjmp .L7
 263 006e 00F4      		brsh .L8
 264 0070 8130      		cpi r24,1
 265 0072 9105      		cpc r25,__zero_reg__
 266 0074 01F0      		breq .L9
 267 0076 0297      		sbiw r24,2
 268 0078 01F0      		breq .L10
 269 007a 00C0      		rjmp .L6
 270               	.L8:
 271 007c 8430      		cpi r24,4
 272 007e 9105      		cpc r25,__zero_reg__
 273 0080 01F4      		brne .+2
 274 0082 00C0      		rjmp .L11
 275 0084 0597      		sbiw r24,5
 276 0086 01F4      		brne .+2
 277 0088 00C0      		rjmp .L12
 278 008a 00C0      		rjmp .L6
 279               	.L9:
  81:main.c        ****     case 1:
  82:main.c        ****         imu_read_data(&imu_data);
 280               		.loc 1 82 0
 281 008c 80E0      		ldi r24,lo8(imu_data)
 282 008e 90E0      		ldi r25,hi8(imu_data)
 283 0090 0E94 0000 		call imu_read_data
 284               	.LVL5:
  83:main.c        ****         gyro_rate = ((double)imu_data.gyro.x *2.5)/32768.0; // Convert to degrees/tick
 285               		.loc 1 83 0
 286 0094 6091 0000 		lds r22,imu_data
 287 0098 7091 0000 		lds r23,imu_data+1
 288 009c 8827      		clr r24
 289 009e 77FD      		sbrc r23,7
 290 00a0 8095      		com r24
 291 00a2 982F      		mov r25,r24
 292 00a4 0E94 0000 		call __floatsisf
 293               	.LVL6:
 294 00a8 20E0      		ldi r18,0
 295 00aa 30E0      		ldi r19,0
 296 00ac 40E2      		ldi r20,lo8(32)
 297 00ae 50E4      		ldi r21,lo8(64)
 298 00b0 0E94 0000 		call __mulsf3
 299               	.LVL7:
 300 00b4 20E0      		ldi r18,0
 301 00b6 30E0      		ldi r19,0
 302 00b8 40E0      		ldi r20,0
 303 00ba 58E3      		ldi r21,lo8(56)
 304 00bc 0E94 0000 		call __mulsf3
 305               	.LVL8:
 306 00c0 6093 0000 		sts gyro_rate,r22
 307 00c4 7093 0000 		sts gyro_rate+1,r23
 308 00c8 8093 0000 		sts gyro_rate+2,r24
 309 00cc 9093 0000 		sts gyro_rate+3,r25
  84:main.c        ****         break;
 310               		.loc 1 84 0
 311 00d0 00C0      		rjmp .L6
 312               	.L10:
  85:main.c        ****     case 2:
  86:main.c        ****         if(startup>0) {
 313               		.loc 1 86 0
 314 00d2 8091 0000 		lds r24,startup
 315 00d6 9091 0000 		lds r25,startup+1
 316 00da 0097      		sbiw r24,0
 317 00dc 01F4      		brne .+2
 318 00de 00C0      		rjmp .L6
  87:main.c        ****             startup--;
 319               		.loc 1 87 0
 320 00e0 0197      		sbiw r24,1
 321 00e2 9093 0000 		sts startup+1,r25
 322 00e6 8093 0000 		sts startup,r24
  88:main.c        ****             gyro_zero += gyro_rate/(double)START_AVG;
 323               		.loc 1 88 0
 324 00ea 20E0      		ldi r18,0
 325 00ec 30E0      		ldi r19,0
 326 00ee 48EC      		ldi r20,lo8(-56)
 327 00f0 52E4      		ldi r21,lo8(66)
 328 00f2 6091 0000 		lds r22,gyro_rate
 329 00f6 7091 0000 		lds r23,gyro_rate+1
 330 00fa 8091 0000 		lds r24,gyro_rate+2
 331 00fe 9091 0000 		lds r25,gyro_rate+3
 332 0102 0E94 0000 		call __divsf3
 333               	.LVL9:
 334 0106 9B01      		movw r18,r22
 335 0108 AC01      		movw r20,r24
 336 010a 6091 0000 		lds r22,gyro_zero
 337 010e 7091 0000 		lds r23,gyro_zero+1
 338 0112 8091 0000 		lds r24,gyro_zero+2
 339 0116 9091 0000 		lds r25,gyro_zero+3
 340 011a 0E94 0000 		call __addsf3
 341               	.LVL10:
 342 011e 6093 0000 		sts gyro_zero,r22
 343 0122 7093 0000 		sts gyro_zero+1,r23
 344 0126 8093 0000 		sts gyro_zero+2,r24
 345 012a 9093 0000 		sts gyro_zero+3,r25
 346 012e 00C0      		rjmp .L6
 347               	.L7:
  89:main.c        ****         }
  90:main.c        ****         break;
  91:main.c        ****     case 3:
  92:main.c        ****         rotation_speed = gyro_rate - gyro_zero;
 348               		.loc 1 92 0
 349 0130 2091 0000 		lds r18,gyro_zero
 350 0134 3091 0000 		lds r19,gyro_zero+1
 351 0138 4091 0000 		lds r20,gyro_zero+2
 352 013c 5091 0000 		lds r21,gyro_zero+3
 353 0140 6091 0000 		lds r22,gyro_rate
 354 0144 7091 0000 		lds r23,gyro_rate+1
 355 0148 8091 0000 		lds r24,gyro_rate+2
 356 014c 9091 0000 		lds r25,gyro_rate+3
 357 0150 0E94 0000 		call __subsf3
 358               	.LVL11:
 359 0154 6093 0000 		sts rotation_speed,r22
 360 0158 7093 0000 		sts rotation_speed+1,r23
 361 015c 8093 0000 		sts rotation_speed+2,r24
 362 0160 9093 0000 		sts rotation_speed+3,r25
  93:main.c        ****         angle += rotation_speed;
 363               		.loc 1 93 0
 364 0164 2091 0000 		lds r18,angle
 365 0168 3091 0000 		lds r19,angle+1
 366 016c 4091 0000 		lds r20,angle+2
 367 0170 5091 0000 		lds r21,angle+3
 368               	.L34:
  94:main.c        ****         while(angle<-180.0) angle+=360.0;
 369               		.loc 1 94 0 discriminator 2
 370 0174 0E94 0000 		call __addsf3
 371               	.LVL12:
 372 0178 8B01      		movw r16,r22
 373 017a 7C01      		movw r14,r24
 374 017c 20E0      		ldi r18,0
 375 017e 30E0      		ldi r19,0
 376 0180 44E3      		ldi r20,lo8(52)
 377 0182 53EC      		ldi r21,lo8(-61)
 378 0184 0E94 0000 		call __ltsf2
 379               	.LVL13:
 380 0188 87FF      		sbrs r24,7
 381 018a 00C0      		rjmp .L16
 382 018c 20E0      		ldi r18,0
 383 018e 30E0      		ldi r19,0
 384 0190 44EB      		ldi r20,lo8(-76)
 385 0192 53E4      		ldi r21,lo8(67)
 386 0194 B801      		movw r22,r16
 387 0196 C701      		movw r24,r14
 388 0198 00C0      		rjmp .L34
 389               	.L16:
  95:main.c        ****         while(angle>=180.0) angle-=360.0;
 390               		.loc 1 95 0 discriminator 1
 391 019a 20E0      		ldi r18,0
 392 019c 30E0      		ldi r19,0
 393 019e 44E3      		ldi r20,lo8(52)
 394 01a0 53E4      		ldi r21,lo8(67)
 395 01a2 B801      		movw r22,r16
 396 01a4 C701      		movw r24,r14
 397 01a6 0E94 0000 		call __gesf2
 398               	.LVL14:
 399 01aa 87FD      		sbrc r24,7
 400 01ac 00C0      		rjmp .L36
 401               		.loc 1 95 0 is_stmt 0 discriminator 2
 402 01ae 20E0      		ldi r18,0
 403 01b0 30E0      		ldi r19,0
 404 01b2 44EB      		ldi r20,lo8(-76)
 405 01b4 53E4      		ldi r21,lo8(67)
 406 01b6 B801      		movw r22,r16
 407 01b8 C701      		movw r24,r14
 408 01ba 0E94 0000 		call __subsf3
 409               	.LVL15:
 410 01be 8B01      		movw r16,r22
 411 01c0 7C01      		movw r14,r24
 412 01c2 00C0      		rjmp .L16
 413               	.L36:
  96:main.c        **** 
  97:main.c        ****         accel_angle = atan2(imu_data.accel.y, imu_data.accel.z)*RAD_TO_DEG;
 414               		.loc 1 97 0 is_stmt 1
 415 01c4 6091 0000 		lds r22,imu_data+10
 416 01c8 7091 0000 		lds r23,imu_data+10+1
 417 01cc 8827      		clr r24
 418 01ce 77FD      		sbrc r23,7
 419 01d0 8095      		com r24
 420 01d2 982F      		mov r25,r24
 421 01d4 0E94 0000 		call __floatsisf
 422               	.LVL16:
 423 01d8 9B01      		movw r18,r22
 424 01da AC01      		movw r20,r24
 425 01dc 6091 0000 		lds r22,imu_data+8
 426 01e0 7091 0000 		lds r23,imu_data+8+1
 427 01e4 8827      		clr r24
 428 01e6 77FD      		sbrc r23,7
 429 01e8 8095      		com r24
 430 01ea 982F      		mov r25,r24
 431 01ec 2983      		std Y+1,r18
 432 01ee 3A83      		std Y+2,r19
 433 01f0 4B83      		std Y+3,r20
 434 01f2 5C83      		std Y+4,r21
 435 01f4 0E94 0000 		call __floatsisf
 436               	.LVL17:
 437 01f8 2981      		ldd r18,Y+1
 438 01fa 3A81      		ldd r19,Y+2
 439 01fc 4B81      		ldd r20,Y+3
 440 01fe 5C81      		ldd r21,Y+4
 441 0200 0E94 0000 		call atan2
 442               	.LVL18:
 443 0204 21EE      		ldi r18,lo8(-31)
 444 0206 3EE2      		ldi r19,lo8(46)
 445 0208 45E6      		ldi r20,lo8(101)
 446 020a 52E4      		ldi r21,lo8(66)
 447 020c 0E94 0000 		call __mulsf3
 448               	.LVL19:
 449 0210 4B01      		movw r8,r22
 450 0212 5C01      		movw r10,r24
 451 0214 6093 0000 		sts accel_angle,r22
 452 0218 7093 0000 		sts accel_angle+1,r23
 453 021c 8093 0000 		sts accel_angle+2,r24
 454 0220 9093 0000 		sts accel_angle+3,r25
  98:main.c        ****         angle = angle*(1.0-beta) + accel_angle*beta;
 455               		.loc 1 98 0
 456 0224 28E4      		ldi r18,lo8(72)
 457 0226 31EE      		ldi r19,lo8(-31)
 458 0228 4AE7      		ldi r20,lo8(122)
 459 022a 5FE3      		ldi r21,lo8(63)
 460 022c B801      		movw r22,r16
 461 022e C701      		movw r24,r14
 462 0230 0E94 0000 		call __mulsf3
 463               	.LVL20:
 464 0234 6B01      		movw r12,r22
 465 0236 7C01      		movw r14,r24
 466 0238 2AE0      		ldi r18,lo8(10)
 467 023a 37ED      		ldi r19,lo8(-41)
 468 023c 43EA      		ldi r20,lo8(-93)
 469 023e 5CE3      		ldi r21,lo8(60)
 470 0240 C501      		movw r24,r10
 471 0242 B401      		movw r22,r8
 472 0244 0E94 0000 		call __mulsf3
 473               	.LVL21:
 474 0248 9B01      		movw r18,r22
 475 024a AC01      		movw r20,r24
 476 024c C701      		movw r24,r14
 477 024e B601      		movw r22,r12
 478 0250 0E94 0000 		call __addsf3
 479               	.LVL22:
 480 0254 6093 0000 		sts angle,r22
 481 0258 7093 0000 		sts angle+1,r23
 482 025c 8093 0000 		sts angle+2,r24
 483 0260 9093 0000 		sts angle+3,r25
  99:main.c        ****         break;
 484               		.loc 1 99 0
 485 0264 00C0      		rjmp .L6
 486               	.L11:
 100:main.c        ****     case 4:
 101:main.c        ****         thrust = -(kp*(angle-target_angle) + kd*rotation_speed);
 487               		.loc 1 101 0
 488 0266 2091 0000 		lds r18,target_angle
 489 026a 3091 0000 		lds r19,target_angle+1
 490 026e 4091 0000 		lds r20,target_angle+2
 491 0272 5091 0000 		lds r21,target_angle+3
 492 0276 6091 0000 		lds r22,angle
 493 027a 7091 0000 		lds r23,angle+1
 494 027e 8091 0000 		lds r24,angle+2
 495 0282 9091 0000 		lds r25,angle+3
 496 0286 0E94 0000 		call __subsf3
 497               	.LVL23:
 498 028a 2091 0000 		lds r18,kp
 499 028e 3091 0000 		lds r19,kp+1
 500 0292 4091 0000 		lds r20,kp+2
 501 0296 5091 0000 		lds r21,kp+3
 502 029a 0E94 0000 		call __mulsf3
 503               	.LVL24:
 504 029e 6B01      		movw r12,r22
 505 02a0 7C01      		movw r14,r24
 506 02a2 2091 0000 		lds r18,rotation_speed
 507 02a6 3091 0000 		lds r19,rotation_speed+1
 508 02aa 4091 0000 		lds r20,rotation_speed+2
 509 02ae 5091 0000 		lds r21,rotation_speed+3
 510 02b2 6091 0000 		lds r22,kd
 511 02b6 7091 0000 		lds r23,kd+1
 512 02ba 8091 0000 		lds r24,kd+2
 513 02be 9091 0000 		lds r25,kd+3
 514 02c2 0E94 0000 		call __mulsf3
 515               	.LVL25:
 516 02c6 9B01      		movw r18,r22
 517 02c8 AC01      		movw r20,r24
 518 02ca C701      		movw r24,r14
 519 02cc B601      		movw r22,r12
 520 02ce 0E94 0000 		call __addsf3
 521               	.LVL26:
 522 02d2 6B01      		movw r12,r22
 523 02d4 7C01      		movw r14,r24
 524 02d6 F7FA      		bst r15,7
 525 02d8 F094      		com r15
 526 02da F7F8      		bld r15,7
 527 02dc F094      		com r15
 102:main.c        ****         if(thrust > 127.0) thrust=127.0;
 528               		.loc 1 102 0
 529 02de 20E0      		ldi r18,0
 530 02e0 30E0      		ldi r19,0
 531 02e2 4EEF      		ldi r20,lo8(-2)
 532 02e4 52E4      		ldi r21,lo8(66)
 533 02e6 C701      		movw r24,r14
 534 02e8 B601      		movw r22,r12
 535 02ea 0E94 0000 		call __gtsf2
 536               	.LVL27:
 537 02ee 1816      		cp __zero_reg__,r24
 538 02f0 04F0      		brlt .L18
 101:main.c        ****         thrust = -(kp*(angle-target_angle) + kd*rotation_speed);
 539               		.loc 1 101 0
 540 02f2 C092 0000 		sts thrust,r12
 541 02f6 D092 0000 		sts thrust+1,r13
 542 02fa E092 0000 		sts thrust+2,r14
 543 02fe F092 0000 		sts thrust+3,r15
 544 0302 00C0      		rjmp .L19
 545               	.L18:
 546               		.loc 1 102 0 discriminator 1
 547 0304 80E0      		ldi r24,0
 548 0306 90E0      		ldi r25,0
 549 0308 AEEF      		ldi r26,lo8(-2)
 550 030a B2E4      		ldi r27,lo8(66)
 551 030c 8093 0000 		sts thrust,r24
 552 0310 9093 0000 		sts thrust+1,r25
 553 0314 A093 0000 		sts thrust+2,r26
 554 0318 B093 0000 		sts thrust+3,r27
 555               	.L19:
 103:main.c        ****         if(thrust < -127.0) thrust=-127.0;
 556               		.loc 1 103 0
 557 031c 20E0      		ldi r18,0
 558 031e 30E0      		ldi r19,0
 559 0320 4EEF      		ldi r20,lo8(-2)
 560 0322 52EC      		ldi r21,lo8(-62)
 561 0324 6091 0000 		lds r22,thrust
 562 0328 7091 0000 		lds r23,thrust+1
 563 032c 8091 0000 		lds r24,thrust+2
 564 0330 9091 0000 		lds r25,thrust+3
 565 0334 0E94 0000 		call __ltsf2
 566               	.LVL28:
 567 0338 87FF      		sbrs r24,7
 568 033a 00C0      		rjmp .L6
 569               		.loc 1 103 0 is_stmt 0 discriminator 1
 570 033c 80E0      		ldi r24,0
 571 033e 90E0      		ldi r25,0
 572 0340 AEEF      		ldi r26,lo8(-2)
 573 0342 B2EC      		ldi r27,lo8(-62)
 574 0344 8093 0000 		sts thrust,r24
 575 0348 9093 0000 		sts thrust+1,r25
 576 034c A093 0000 		sts thrust+2,r26
 577 0350 B093 0000 		sts thrust+3,r27
 578 0354 00C0      		rjmp .L6
 579               	.L12:
 104:main.c        ****         break;
 105:main.c        ****     case 5:
 106:main.c        ****         //printf("%6d\n", (int)thrust);
 107:main.c        ****         if(drive_state == DRIVE_STATE_START) {
 580               		.loc 1 107 0 is_stmt 1
 581 0356 8091 0000 		lds r24,drive_state
 582 035a 8111      		cpse r24,__zero_reg__
 583 035c 00C0      		rjmp .L22
 108:main.c        ****             if(angle < 0.0) {
 584               		.loc 1 108 0
 585 035e 20E0      		ldi r18,0
 586 0360 30E0      		ldi r19,0
 587 0362 A901      		movw r20,r18
 588 0364 6091 0000 		lds r22,angle
 589 0368 7091 0000 		lds r23,angle+1
 590 036c 8091 0000 		lds r24,angle+2
 591 0370 9091 0000 		lds r25,angle+3
 592 0374 0E94 0000 		call __ltsf2
 593               	.LVL29:
 594 0378 87FF      		sbrs r24,7
 595 037a 00C0      		rjmp .L33
 109:main.c        ****                 drive_state = DRIVE_STATE_NEG_START;
 596               		.loc 1 109 0
 597 037c 81E0      		ldi r24,lo8(1)
 598 037e 00C0      		rjmp .L35
 599               	.L33:
 110:main.c        ****             }else{
 111:main.c        ****                 drive_state = DRIVE_STATE_POS_START;
 600               		.loc 1 111 0
 601 0380 82E0      		ldi r24,lo8(2)
 602               	.L35:
 603 0382 8093 0000 		sts drive_state,r24
 604 0386 00C0      		rjmp .L6
 605               	.L22:
 112:main.c        ****             }
 113:main.c        ****         }else if(drive_state == DRIVE_STATE_NEG_START) {
 606               		.loc 1 113 0
 607 0388 8130      		cpi r24,lo8(1)
 608 038a 01F4      		brne .L25
 114:main.c        ****             if(angle >= 0.0) {
 609               		.loc 1 114 0
 610 038c 20E0      		ldi r18,0
 611 038e 30E0      		ldi r19,0
 612 0390 A901      		movw r20,r18
 613 0392 6091 0000 		lds r22,angle
 614 0396 7091 0000 		lds r23,angle+1
 615 039a 8091 0000 		lds r24,angle+2
 616 039e 9091 0000 		lds r25,angle+3
 617 03a2 0E94 0000 		call __gesf2
 618               	.LVL30:
 619 03a6 87FD      		sbrc r24,7
 620 03a8 00C0      		rjmp .L6
 621               	.L28:
 115:main.c        ****                 drive_state = DRIVE_STATE_DRIVING;
 622               		.loc 1 115 0
 623 03aa 83E0      		ldi r24,lo8(3)
 624 03ac 00C0      		rjmp .L35
 625               	.L25:
 116:main.c        ****             }
 117:main.c        ****         }else if(drive_state == DRIVE_STATE_POS_START) {
 626               		.loc 1 117 0
 627 03ae 8230      		cpi r24,lo8(2)
 628 03b0 01F4      		brne .L27
 118:main.c        ****             if(angle <= 0.0) {
 629               		.loc 1 118 0
 630 03b2 20E0      		ldi r18,0
 631 03b4 30E0      		ldi r19,0
 632 03b6 A901      		movw r20,r18
 633 03b8 6091 0000 		lds r22,angle
 634 03bc 7091 0000 		lds r23,angle+1
 635 03c0 8091 0000 		lds r24,angle+2
 636 03c4 9091 0000 		lds r25,angle+3
 637 03c8 0E94 0000 		call __lesf2
 638               	.LVL31:
 639 03cc 1816      		cp __zero_reg__,r24
 640 03ce 04F0      		brlt .L6
 641 03d0 00C0      		rjmp .L28
 642               	.L27:
 119:main.c        ****                 drive_state = DRIVE_STATE_DRIVING;
 120:main.c        ****             }
 121:main.c        ****         }else if(drive_state == DRIVE_STATE_DRIVING) {
 643               		.loc 1 121 0
 644 03d2 8330      		cpi r24,lo8(3)
 645 03d4 01F4      		brne .L6
 122:main.c        ****             motor_drive(0, thrust);
 646               		.loc 1 122 0
 647 03d6 6091 0000 		lds r22,thrust
 648 03da 7091 0000 		lds r23,thrust+1
 649 03de 8091 0000 		lds r24,thrust+2
 650 03e2 9091 0000 		lds r25,thrust+3
 651 03e6 0E94 0000 		call __fixsfsi
 652               	.LVL32:
 653 03ea 80E0      		ldi r24,0
 654 03ec 0E94 0000 		call motor_drive
 655               	.LVL33:
 123:main.c        ****             motor_drive(1, thrust);
 656               		.loc 1 123 0
 657 03f0 6091 0000 		lds r22,thrust
 658 03f4 7091 0000 		lds r23,thrust+1
 659 03f8 8091 0000 		lds r24,thrust+2
 660 03fc 9091 0000 		lds r25,thrust+3
 661 0400 0E94 0000 		call __fixsfsi
 662               	.LVL34:
 663 0404 81E0      		ldi r24,lo8(1)
 664 0406 0E94 0000 		call motor_drive
 665               	.LVL35:
 666               	.L6:
 124:main.c        ****         }
 125:main.c        ****     }
 126:main.c        **** 
 127:main.c        ****     loop_count++;
 667               		.loc 1 127 0
 668 040a 8091 0000 		lds r24,loop_count
 669 040e 9091 0000 		lds r25,loop_count+1
 670 0412 0196      		adiw r24,1
 128:main.c        ****     if(loop_count==10) {
 671               		.loc 1 128 0
 672 0414 8A30      		cpi r24,10
 673 0416 9105      		cpc r25,__zero_reg__
 674 0418 01F0      		breq .L29
 127:main.c        ****     loop_count++;
 675               		.loc 1 127 0
 676 041a 9093 0000 		sts loop_count+1,r25
 677 041e 8093 0000 		sts loop_count,r24
 678 0422 00C0      		rjmp .L5
 679               	.L29:
 129:main.c        ****         loop_count=0;
 680               		.loc 1 129 0
 681 0424 1092 0000 		sts loop_count+1,__zero_reg__
 682 0428 1092 0000 		sts loop_count,__zero_reg__
 683               	.L5:
 684               	/* epilogue start */
 130:main.c        ****     }
 131:main.c        **** }
 685               		.loc 1 131 0
 686 042c 0F90      		pop __tmp_reg__
 687 042e 0F90      		pop __tmp_reg__
 688 0430 0F90      		pop __tmp_reg__
 689 0432 0F90      		pop __tmp_reg__
 690 0434 DF91      		pop r29
 691 0436 CF91      		pop r28
 692 0438 FF91      		pop r31
 693 043a EF91      		pop r30
 694 043c BF91      		pop r27
 695 043e AF91      		pop r26
 696 0440 9F91      		pop r25
 697 0442 8F91      		pop r24
 698 0444 7F91      		pop r23
 699 0446 6F91      		pop r22
 700 0448 5F91      		pop r21
 701 044a 4F91      		pop r20
 702 044c 3F91      		pop r19
 703 044e 2F91      		pop r18
 704 0450 1F91      		pop r17
 705 0452 0F91      		pop r16
 706 0454 FF90      		pop r15
 707 0456 EF90      		pop r14
 708 0458 DF90      		pop r13
 709 045a CF90      		pop r12
 710 045c BF90      		pop r11
 711 045e AF90      		pop r10
 712 0460 9F90      		pop r9
 713 0462 8F90      		pop r8
 714 0464 0F90      		pop r0
 715 0466 0FBE      		out __SREG__,r0
 716 0468 0F90      		pop r0
 717 046a 1F90      		pop r1
 718 046c 1895      		reti
 719               		.cfi_endproc
 720               	.LFE9:
 722               	.global	print_count
 723               		.section .bss
 726               	print_count:
 727 0000 0000      		.zero	2
 728               	.global	loop_count
 731               	loop_count:
 732 0002 0000      		.zero	2
 733               		.comm	thrust,4,1
 734               	.global	target_angle
 737               	target_angle:
 738 0004 0000 0000 		.zero	4
 739               	.global	kd
 740               		.data
 743               	kd:
 744 0000 00        		.byte	0
 745 0001 00        		.byte	0
 746 0002 96        		.byte	-106
 747 0003 42        		.byte	66
 748               	.global	kp
 751               	kp:
 752 0004 CD        		.byte	-51
 753 0005 CC        		.byte	-52
 754 0006 0C        		.byte	12
 755 0007 40        		.byte	64
 756               		.comm	nck_data,9,1
 757               		.comm	imu_data,18,1
 758               	.global	angle
 759               		.section .bss
 762               	angle:
 763 0008 0000 0000 		.zero	4
 764               		.comm	accel_angle,4,1
 765               		.comm	rotation_speed,4,1
 766               		.comm	gyro_rate,4,1
 767               	.global	gyro_zero
 770               	gyro_zero:
 771 000c 0000 0000 		.zero	4
 772               	.global	beta
 773               		.section	.rodata
 776               	beta:
 777 0000 0A        		.byte	10
 778 0001 D7        		.byte	-41
 779 0002 A3        		.byte	-93
 780 0003 3C        		.byte	60
 781               	.global	alpha
 784               	alpha:
 785 0004 AC        		.byte	-84
 786 0005 C5        		.byte	-59
 787 0006 27        		.byte	39
 788 0007 37        		.byte	55
 789               	.global	startup
 790               		.data
 793               	startup:
 794 0008 6400      		.word	100
 795               	.global	drive_state
 796               		.section .bss
 799               	drive_state:
 800 0010 00        		.zero	1
 801               		.text
 802               	.Letext0:
 803               		.file 3 "/usr/lib/avr/include/stdint.h"
 804               		.file 4 "/usr/lib/avr/include/stdio.h"
 805               		.file 5 "imu.h"
 806               		.file 6 "nunchuck.h"
 807               		.file 7 "serial.h"
 808               		.file 8 "/usr/lib/avr/include/math.h"
 809               		.file 9 "motor.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc2uQF9h.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc2uQF9h.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc2uQF9h.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc2uQF9h.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc2uQF9h.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc2uQF9h.s:12     .text:0000000000000000 setup_timer
     /tmp/cc2uQF9h.s:50     .text.startup:0000000000000000 main
     /tmp/cc2uQF9h.s:133    .text:000000000000001c __vector_14
     /tmp/cc2uQF9h.s:731    .bss:0000000000000002 loop_count
                            *COM*:0000000000000012 imu_data
                            *COM*:0000000000000004 gyro_rate
     /tmp/cc2uQF9h.s:793    .data:0000000000000008 startup
     /tmp/cc2uQF9h.s:770    .bss:000000000000000c gyro_zero
                            *COM*:0000000000000004 rotation_speed
     /tmp/cc2uQF9h.s:762    .bss:0000000000000008 angle
                            *COM*:0000000000000004 accel_angle
     /tmp/cc2uQF9h.s:737    .bss:0000000000000004 target_angle
     /tmp/cc2uQF9h.s:751    .data:0000000000000004 kp
     /tmp/cc2uQF9h.s:743    .data:0000000000000000 kd
                            *COM*:0000000000000004 thrust
     /tmp/cc2uQF9h.s:799    .bss:0000000000000010 drive_state
     /tmp/cc2uQF9h.s:726    .bss:0000000000000000 print_count
                            *COM*:0000000000000009 nck_data
     /tmp/cc2uQF9h.s:776    .rodata:0000000000000000 beta
     /tmp/cc2uQF9h.s:784    .rodata:0000000000000004 alpha

UNDEFINED SYMBOLS
uart_init
uartfile
__iob
i2c_init
imu_init
__floatsisf
__mulsf3
__divsf3
__addsf3
__subsf3
__ltsf2
__gesf2
__gtsf2
__lesf2
__fixsfsi
imu_read_data
atan2
motor_drive
__do_copy_data
__do_clear_bss
